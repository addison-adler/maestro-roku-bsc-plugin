import {
    FunctionStatement,
    IfStatement,
    BrsFile,
    XmlFile,
    Program,
    Editor,
    createSGAttribute
} from 'brighterscript';
import {util, Lexer, Parser, ParseMode } from 'brighterscript';
import undent from 'undent';
import type { MaestroFile } from '../files/MaestroFile';
import { FileType } from '../files/FileType';
import type { ProjectFileMap } from '../files/ProjectFileMap';
import {
    addXmlBindingErrorValidatingBindings,
    addXmlBindingNoVMClassDefined,
    addXmlBindingParentHasDuplicateField,
    addXmlBindingVMClassNotFound
} from '../utils/Diagnostics';
import { makeASTFunction } from '../utils/Utils';
import type Binding from './Binding';
import { BindingType } from './BindingType';
import { XMLTag } from './XMLTag';
import { RawCodeStatement } from '../utils/RawCodeStatement';
import type { SGComponent, SGElement, SGNode } from 'brighterscript/dist/parser/SGTypes';
import { addImport } from '../Utils';
import type { FileFactory } from '../utils/FileFactory';
import type { DependencyGraph } from 'brighterscript/dist/DependencyGraph';

// eslint-disable-next-line
import * as fsExtra from 'fs-extra';
import { BrsTranspileState } from 'brighterscript/dist/parser/BrsTranspileState';
import { SourceNode } from 'source-map';
import type { MaestroConfig } from '../files/MaestroConfig';
import { isFunctionStatement } from 'brighterscript';

import { SGScript } from 'brighterscript/dist/parser/SGTypes';

export class BindingProcessor {
    constructor(public fileMap: ProjectFileMap, public fileFactory: FileFactory, public config: MaestroConfig) {
    }

    public generateCodeForXMLFile(file: MaestroFile, program: Program, astEditor: Editor) {
        if (!file || (file.fileType !== FileType.Xml)
        ) {
            throw new Error('was given a non-xml file');
        }
        if (!file.associatedFile && file.vmClassName) {
            if (this.config.mvvm.createCodeBehindFilesWhenNeeded) {

                //if (xmlFile) {
                let vmFile = this.fileMap.getFileForClass(file.vmClassName);
                if (vmFile) {

                    let xmlFile = file.bscFile as XmlFile;
                    // eslint-disable-next-line @typescript-eslint/dot-notation
                    let dg = program['dependencyGraph'] as DependencyGraph;
                    dg.addDependency(xmlFile.dependencyGraphKey, vmFile.bscFile.dependencyGraphKey);
                    xmlFile.ast.componentElement?.addChild(this.createSGScript(xmlFile.pkgPath.replace('.xml', '.brs')));
                    fsExtra.outputFileSync(xmlFile.destPath.replace('.xml', '.brs'), this.getCodeBehindText(file, vmFile.bscFile as BrsFile));
                } else {
                    console.error('missing vm file ' + file.vmClassName);
                }

                // } else {
                //     console.error('cannot generated codebehind file transpile without entry');
                // }
            }
        } else {
            (file.bscFile as XmlFile).parser.invalidateReferences();
            this.addFindNodeVarsMethodForFile(file, astEditor);
            if (this.config.mvvm.callCreateNodeVarsInInit) {
                this.addInitCreateNodeVarsCall(file.associatedFile.bscFile as BrsFile, astEditor);
            }
            if (this.config.mvvm.insertCreateVMMethod) {
                this.addVMConstructor(file, astEditor);
            }
            if (file.bindings.length > 0) {
                this.addBindingMethodsForFile(file, astEditor);
            }
        }

    }
    private getCodeBehindText(file: MaestroFile, brsFile: BrsFile): any {
        console.log('generating code behind text for file', file.fullPath);
        let text = undent`
            'generated by maestro-bsc-plugin
            function init()
                m_createNodeVars()
            end function
            ${this.getNodeVarMethodText(file)}
            function m_createVM()
                m.vm = ${file.vmClassName.replace(/\./gim, '_')}()
                m.vm.initialize()
                mx_initializeBindings()
            end function
        `;
        if (file.bindings.length > 0) {
            text += this.getBindingMethodsText(file, brsFile);
        }

        return text;
    }


    private getBindingMethodsText(file: MaestroFile, brsFile: BrsFile) {
        let bindings = file.bindings.concat(file.getAllParentBindings());
        if (bindings.length > 0) {
            //TODO convert to pure AST
            let bindingInitStatement = this.getBindingInitMethod(
                bindings.filter(
                    (b) => b.properties.type !== BindingType.static &&
                        b.properties.type !== BindingType.code
                ), file.bscFile as XmlFile);
            let staticBindingStatement = this.getStaticBindingsMethod(bindings.filter(
                (b) => b.properties.type === BindingType.static ||
                    b.properties.type === BindingType.code
            ), file.bscFile as XmlFile);
            let text = '';
            let state = new BrsTranspileState(brsFile);
            text += new SourceNode(null, null, state.srcPath, bindingInitStatement.transpile(state)).toString() + '\n';
            text += new SourceNode(null, null, state.srcPath, staticBindingStatement.transpile(state)).toString() + '\n';
            return text;
        }
    }

    private createSGScript(uri: string) {
        return new SGScript({
            startTagOpen: { text: '<' },
            startTagName: { text: 'script' },
            attributes: [createSGAttribute('uri', `pkg:/${uri}`)],
            startTagClose: { text: '' }
        });
    }
    /**
     * given a file, will load it's xml, identify bindings and clear out binding text.
     * @param file - file to parse bindings for
     */
    public parseBindings(file: MaestroFile) {
        if (!file || file.fileType !== FileType.Xml) {
            throw new Error('was given a non-xml file');
        }
        file.resetBindings();

        let xmlFile = file.bscFile as XmlFile;
        //we have to reparse the xml each time we do this..
        xmlFile.parse(xmlFile.fileContents);
        // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression
        xmlFile.ast.componentElement?.setAttributeValue('vm', undefined);
        xmlFile.needsTranspiled = true;
        file.bindings = this.processElements(file);
    }

    public addNodeVarsMethodForRegularXMLFile(file: MaestroFile, astEditor: Editor) {
        if (!file || file.fileType !== FileType.Xml) {
            throw new Error('was given a non-xml file');
        }
        if (file.associatedFile) {
            file.resetBindings();
            let xmlFile = file.bscFile as XmlFile;

            //we have to reparse the xml each time we do this..
            xmlFile.parse(xmlFile.fileContents);
            this.processElementsForTagIds(file);
            if (file.tagIds.size > 0) {
                this.addFindNodeVarsMethodForFile(file, astEditor);
                if (this.config.mvvm.callCreateNodeVarsInInit) {
                    this.addInitCreateNodeVarsCall(file.associatedFile.bscFile as BrsFile, astEditor);
                }
            }

        }
    }

    public processElementsForTagIds(file: MaestroFile) {
        let xmlFile = file.bscFile as XmlFile;
        file.componentTag = xmlFile.ast.componentElement;
        for (let sgNode of this.getAllChildren(file.componentTag)) {
            let id = sgNode.getAttributeValue('id');
            if (id) {
                file.tagIds.add(id);
            }
        }
        // console.log('got tagids', file.tagIds);
    }

    private addInitCreateNodeVarsCall(file: BrsFile, astEditor: Editor) {
        let initFunc = file.parser.ast.statements.find((s) => isFunctionStatement(s) && s.tokens.name.text.toLowerCase() === 'init') as FunctionStatement;
        if (initFunc) {
            astEditor.arraySplice(initFunc.func.body.statements, 0, 0, new RawCodeStatement(undent`
            m_createNodeVars()
            `));
        }
        if (!initFunc && this.config.mvvm.callCreateNodeVarsInInit) {
            console.log('init func was not present in ', file.pkgPath, ' adding init function');
            let initFunc = makeASTFunction(undent`
                function init()
                    m_createNodeVars()
                end function
            `);
            // astEditor.arrayPush(file.parser.ast.statements, initFunc);
            // astEditor.edit((data) => {
            //     data.oldValue = file.parser.ast.statements.find((s) => isFunctionStatement(s) && s.tokens.name.text.toLowerCase() === 'init');
            //     file.parser.references.functionStatementLookup.set('init', initFunc);
            // }, (data) => {
            //     file.parser.references.functionStatementLookup.set('init', data.oldValue);
            // });
            astEditor.arrayPush(file.parser.ast.statements, initFunc);
        }
    }

    public getAllChildren(component: SGComponent) {
        let result = [] as SGElement[];
        this.getNodeChildren(component.childrenElement, result);
        return result;
    }

    public getNodeChildren(node: SGNode, results: SGElement[] = []) {
        if (node) {
            results.push(node);
            if (node.elements) {
                for (let child of node.elements) {
                    this.getNodeChildren(child, results);
                }
            }
        }
    }

    public processElements(file: MaestroFile) {
        let xmlFile = file.bscFile as XmlFile;
        file.componentTag = xmlFile.ast.componentElement;
        const allTags = this.getAllChildren(file.componentTag).map((c) => new XMLTag(c, file, false)
        );

        let interfaceFields = file.componentTag.interfaceElement.fields.map((c) => new XMLTag(c, file, true)
        );
        allTags.push(...interfaceFields);

        for (let tag of allTags) {
            if (tag.id) {
                (tag.isTopTag ? file.fieldIds : file.tagIds).add(tag.id);
            }
        }

        let tagsWithBindings = allTags.filter((t) => t.hasBindings);
        return util.flatMap(tagsWithBindings, (t) => t.bindings);
    }

    public validateBindings(file: MaestroFile) {
        if (
            !file ||
            (file.fileType !== FileType.Xml)
        ) {
            throw new Error('was given a non-xml file');
        }
        let errorCount = 0;

        try {
            let allParentIds = file.getAllParentTagIds();
            let allParentFieldIds = file.getAllParentFieldIds();
            for (let id of file.fieldIds) {
                if (allParentFieldIds.has(id)) {
                    addXmlBindingParentHasDuplicateField(file, id, 1);
                    errorCount++;
                }
            }
            for (let id of file.tagIds) {
                if (allParentIds.has(id)) {
                    addXmlBindingParentHasDuplicateField(file, id, 1);
                    errorCount++;
                }
            }
        } catch (e) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            addXmlBindingErrorValidatingBindings(file, e.message);
            errorCount++;
        }

        if (file.bindings.length > 0) {

            // if (!file.associatedFile) {
            //     addXmlBindingNoCodeBehind(file);
            // }

            if (!file.vmClassName) {
                if (errorCount === 0) {
                    addXmlBindingNoVMClassDefined(file);
                    errorCount++;
                }

            } else {

                file.bindingClass = this.fileMap.allClasses[file.vmClassName];

                if (!file.bindingClass) {
                    addXmlBindingVMClassNotFound(file);
                    errorCount++;

                } else {
                    for (let binding of file.bindings.filter((b) => b.isValid)) {
                        binding.validateAgainstClass();
                        errorCount += binding.isValid ? 0 : 1;
                    }
                    let bindingFile = this.fileMap.getFileForClass(file.vmClassName);
                    if (bindingFile) {
                        bindingFile.bindingTargetFiles.add(file.bscFile as XmlFile);
                    }
                }
            }
        }

        file.isValid = errorCount === 0;
    }

    private addBindingMethodsForFile(file: MaestroFile, astEditor: Editor) {
        //TODO - use AST for this.
        let associatedMFile = file.associatedFile.bscFile as BrsFile;
        let bindings = file.bindings.concat(file.getAllParentBindings());
        if (bindings.length > 0) {
            //TODO convert to pure AST
            let bindingInitStatement = this.getBindingInitMethod(
                bindings.filter(
                    (b) => b.properties.type !== BindingType.static &&
                        b.properties.type !== BindingType.code
                ), file.bscFile as XmlFile);
            let staticBindingStatement = this.getStaticBindingsMethod(bindings.filter(
                (b) => b.properties.type === BindingType.static ||
                    b.properties.type === BindingType.code
            ), file.bscFile as XmlFile);

            if (bindingInitStatement) {
                astEditor.arrayPush(associatedMFile.parser.statements, bindingInitStatement);
                file.associatedFile.isASTChanged = true;
            }
            if (staticBindingStatement) {
                astEditor.arrayPush(associatedMFile.parser.statements, staticBindingStatement);
                file.associatedFile.isASTChanged = true;
            }
        }
    }

    private makeASTFunction(source: string): FunctionStatement | undefined {
        let tokens = Lexer.scan(source).tokens;
        let { statements } = Parser.parse(tokens, { mode: ParseMode.BrighterScript });
        if (statements && statements.length > 0) {
            return statements[0] as FunctionStatement;
        }
        return undefined;
    }

    private getBindingInitMethod(bindings: Binding[], file: XmlFile): FunctionStatement {
        let func = makeASTFunction(undent`
            function m_initBindings()
                if m.vm <> invalid
                    vm = m.vm
                end if
            end function
        `);

        if (func) {
            let ifStatement = func.func.body.statements[0] as IfStatement;

            for (let binding of bindings) {
                ifStatement.thenBranch.statements.push(new RawCodeStatement(binding.getInitText(), file, binding.range));
            }

            ifStatement.thenBranch.statements.push(
                new RawCodeStatement(undent`
                    if vm.onBindingsConfigured <> invalid
                        vm.onBindingsConfigured()
                    end if
                `)
            );
        }

        return func;
    }

    private getStaticBindingsMethod(bindings: Binding[], file: XmlFile): FunctionStatement {
        let func = makeASTFunction(undent`
            function m_initStaticBindings()
                if m.vm <> invalid
                    vm = m.vm
                end if
            end function
        `);

        if (func) {
            let ifStatement = func.func.body.statements[0] as IfStatement;

            for (let binding of bindings) {
                ifStatement.thenBranch.statements.push(new RawCodeStatement(binding.getStaticText(), file, binding.range));

            }
        }
        return func;
    }

    private addFindNodeVarsMethodForFile(file: MaestroFile, astEditor: Editor) {
        let createNodeVarsFunction = this.makeASTFunction(this.getNodeVarMethodText(file));
        let brsFile = file.associatedFile.bscFile as BrsFile;
        if (createNodeVarsFunction && brsFile.parser) {
            astEditor.arrayPush(brsFile.parser.statements, createNodeVarsFunction);
            file.associatedFile.isASTChanged = true;
        }
    }

    private getNodeVarMethodText(file: MaestroFile) {
        let tagIds = Array.from(file.getAllParentTagIds().values()).concat(
            Array.from(file.tagIds.values())
        );

        if (tagIds.length > 0) {
            return undent`
                function m_createNodeVars()
                    for each id in [ ${tagIds.map((id) => `"${id}"`).join(',')}]
                        m[id] = m.top.findNode(id)
                    end for
                end function
            `;
        } else {
            return undent`
                function m_createNodeVars()
                end function
          `;
        }
    }

    private addVMConstructor(file: MaestroFile, astEditor: Editor) {
        console.log('addVM ', file.fullPath, file.bscFile === undefined);
        console.log('no initialize function, adding one');
        let func = makeASTFunction(this.getVMInitializeText(file));

        if (func) {
            let vmFile = this.fileMap.getFileForClass(file.vmClassName);
            if (vmFile) {
                addImport(file.associatedFile.bscFile as BrsFile, vmFile.bscFile.pkgPath, astEditor);
                (file.associatedFile.bscFile as BrsFile).parser.statements.push(func);
                file.associatedFile.isASTChanged = true;
            } else {
                console.error(`file for vm class ${file.vmClassName} was not found!`);
            }
        }
    }

    private getVMInitializeText(file: MaestroFile) {
        return undent`
            function m_createVM()
                m.vm = new ${file.vmClassName}()
                m.vm.initialize()
                mx_initializeBindings()
            end function
        `;
    }
}
